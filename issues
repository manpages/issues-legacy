#!/bin/bash

# Print usage and exit from anywhere.
export TOP_PID=$$
term() {
  kill -s TERM $TOP_PID
}

ok() {
  kill -s USR1 $TOP_PID
}
trap "echo Ok; exit 0" USR1

init() {
  [ -d '.issues' ] || mkdir -p .issues/open .issues/resolved .issues/wontfix
}

display() {
  [ -z $2 ] && what='title' || what=$2
  for issue in $(ls -1pt $1 | grep /); do
    echo -n "$issue "
    cat $1/$issue/$what
  done
}

context() {
  awk "NR==$2,NR==$3{print NR \"  \" \$0}" $1
}

open() {
  display .issues/open && ok
}

resolved() {
  display .issues/resolved && ok
}

closed() {
  display .issues/wontfix
  display .issues/resolved && ok
}

#nextid() {
#  [ -z $1 ] && path=.issues || path=.issues/$1/..
#  count=1
#  for tag in $path/*; do
#    if [ -d $tag ]; then
#      echo $tag >> /tmp/dbg
#      (( count+=$(ls -1p $tag | grep / | wc -l) ))
#    fi
#  done
#  echo $count
#}

nextid() {
  </dev/urandom tr -dc a-z0-9_ | head -c4
}

add() {
  path=$1
  echo "ADDING TO ${path}"
  shift

  errmsg='Short summary is required'
  trap "echo $errmsg; exit 1" TERM
  [ -z $1 ] && term

  issue=".issues/$path/$(nextid $path)/"
  title="$*"
  echo "What do you have to say? Ctrl-D stops. Leave blank to cancel."
  summary=$(cat)

  errmsg='Canceled'
  trap "echo $errmsg; exit 1" TERM
  [ -z "$summary" ] && term

  mkdir -p "$issue"
  echo "$title" > "$issue/title"
  echo "$summary" > "$issue/summary"

  errmsg='Ok'
  trap "echo $errmsg; exit 0" TERM
  term
}

comment() {
  path=$1
  shift 

  # wow how hardcode much boilerplate
  [ -d .issues/open/$path ] && add open/$path $*
  [ -d .issues/resolved/$path ] && add resolved/$path $*
  [ -d .issues/wontfix/$path ] && add wontfix/$path $*

  errmsg="$path not found in .issues or no summary supplied"
  trap "echo $errmsg; exit 1" TERM
  term
}

resolve() {
  id=$1
  shift

  [ -d .issues/open/$id ] && mv -v .issues/open/$id .issues/resolved/ && trap "exit 0" TERM && term

  errmsg="$id is not an open issue"
  trap "echo $errmsg; exit 1" TERM
  term
}

wontfix() {
  id=$1
  shift

  [ -d .issues/open/$id ] && mv .issues/open/$id .issues/wontfix/

  errmsg="$id is not an open issue"
  trap "echo $errmsg; exit 1" TERM
  term
}

view() {
  path=$1
  shift 

  # wow how hardcode much boilerplate
  [ -d .issues/open/$path ] && view_do open/$path $* && ok
  [ -d .issues/resolved/$path ] && view_do resolved/$path $* && ok
  [ -d .issues/wontfix/$path ] && view_do wontfix/$path $* && ok

  errmsg="$path not found in .issues or no summary supplied"
  trap "echo $errmsg; exit 1" TERM
  term
}

view_do() {
  path=$1
  [ -z $2 ] && depth=1 || depth=$2

  if [ -d .issues/$path ]; then
    pretty_print $path $depth
    (( depth+=1 ))
    for sub in $(ls -1pt .issues/$path/ | grep /); do
      view_do $path/$sub $depth
    done
  else
    errmsg="$path not found"
    trap "echo $errmsg; exit 1" TERM
    term
  fi
}

dereference() {
  cat $1
}

pretty_print() {
  path=$1
  depth=$2
  indent=""
  for x in $(seq 0 $depth); do
    indent+="  "
  done #                                   vvv This thing looks like a very tall lambda
  cat <(echo -n "$path/ ")                   \
      .issues/$path/title                     \
      <(echo "---") <(echo)                    \
      <(dereference .issues/$path/summary)      \
      <(echo) <(echo "* * *") <(echo) <(echo)   |\
    awk "{print \"${indent}\"\$0}"
}

errmsg='Git repository not found.'
trap "echo $errmsg; exit 1" TERM
[ -d '.git' ] || term

errmsg='Supported actions: init, open, add, comment, resolve, wontfix, read'
trap "echo $errmsg; exit 1" TERM
verb=$([ -z $1 ] && term || echo $1 )
shift

# initialization
[ $verb == 'init' ] && init && ok

# major tags
[ $verb == 'open' ] && open
[ $verb == 'closed' ] && closed
[ $verb == 'resolved' ] && resolved

# tags

# work
[ $verb == 'add' ] && add open $*
[ $verb == 'comment' ] && comment $*
[ $verb == 'resolve' ] && resolve $*
[ $verb == 'wontfix' ] && wontfix $*

# read
[ $verb == 'view' ] && view $*

errmsg='Supported actions: init, open, add, comment, resolve, wontfix'
trap "echo $errmsg; exit 1" TERM
term
